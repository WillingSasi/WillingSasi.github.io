---

layout:     post
title:      "面经总结-字节跳动抖音1面"
subtitle:   "测开岗位"
date:       2021-11-11 11:00:00
author:     "WS"
header-img: "img/post-bg-2015.jpg"
catalog:    true
tags:
    - 面经
    - 字节跳动
---

###  先说总结：



### 关键问答流程：

一面：

1. Q：Java oom原因？

   提供更大的堆空间即可。除了前面的因素还有更复杂的成因：

   流量/数据量峰值

   内存泄漏：Java中的内存泄漏是由于GC无法识别一些已经不再使用的对象，而这些未使用的对象一直留在堆空间中，这种堆积最终会导致

1. Q：hashmap hashtable？

   HashMap和Hashtable的比较是Java面试中的常见问题。Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。

   1.两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全

   Hashtable的实现方法里面都添加了synchronized关键字来确保线程同步，因此相对而言HashMap性能会高一些，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合。

   2.HashMap可以使用null作为key，而Hashtable则不允许null作为key
   虽说HashMap支持null值作为key，不过建议还是尽量避免这样使用，因为一旦不小心使用了，若因此引发一些问题，排查起来很是费事

   3.HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类

   HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75

   4.HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1

   5.两者计算hash的方法不同
   Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模

   - Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。
   - 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。
   - HashMap可以通过下面的语句进行同步：
     Map m = Collections.synchronizeMap(hashMap);

1. Q：线程池的参数？

   序号名称类型含义

   1corePoolSizeint核心线程池大小

   2maximumPoolSizeint最大线程池大小

   3keepAliveTimelong线程最大空闲时间

   4unitTimeUnit时间单位

   5workQueueBlockingQueue<`Runnable`>线程等待队列

   6threadFactoryThreadFactory线程创建工厂

   7handlerRejectedExecutionHandler拒绝策略

   

   ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。

   

   **wait()和sleep()的区别**
   sleep是线程中的方法，但是wait是Object中的方法。
   sleep方法不会释放lock，**但是wait会释放，而且会加入到等待队列中。**

   Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。   

       public static ExecutorService newFixedThreadPool(int nThreads)
       
       创建固定数目线程的线程池。
       
       public static ExecutorService newCachedThreadPool()
       
       创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线   程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
       
       public static ExecutorService newSingleThreadExecutor()
       
       创建一个单线程化的Executor。
       
       public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
       
       创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。
   
1. Q：sql索引类型？联合索引？

   1.普通索引
   2.唯一索引：索引列的值必须唯一，但允许有空值
   3.主键索引：一个表只能有一个主键，不允许有空
   4.组合索引
   5.全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配

   ### 缺点

   1.虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行insert、update和delete。因为更新表时，不仅要保存数据，还要保存一下索引文件。
   2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会增长很快。
   索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句

1. Q：linux 统计某个单词出现总次数？

   grep -o objStr filename|wc -l

1. Q：按比例分摊优惠券算法如何测试？

1. 算法题：两个有序数据，合并成一个有序数组？考虑重复元素情况

