---

layout:     post
title:      "面经总结-自如效能平台1面"
subtitle:   "开发岗位"
date:       2021-11-15 11:00:00
author:     "WS"
header-img: "img/post-bg-2015.jpg"
catalog:    true
tags:
    - 面经
    - 自如
---

###  先说总结：

​     问的技术问题挺多的，确实是搞效能开发的，面试中我没打好的问题不少，但还是进2面了，后面再多准备吧。

### 关键问答流程：

一面：

1. Q：sandbox对接微服务怎么做？

2. Q：线上实际并发量？

3. Q：java List， ArrayList LinkList 区别？超大数据集合，存储用那个比较好？内存模型

   ![img](https://img2018.cnblogs.com/blog/838837/201905/838837-20190521092648019-983754481.png)

   - 同样查找, 时间复杂度都是O(N), 但是数组要比链表快

     因为数组的连续内存, 会有一部分或者全部数据一起进入到CPU缓存, 而链表还需要在去内存中根据上下游标查找, CPU缓存比内存块太多

   - 数据大小固定, 不适合动态存储, 动态添加, 内存为一连续的地址, 可随机访问, 查询速度快

   - 链表代销可变, 扩展性强, 只能顺着指针的方向查询, 速度较慢

     **ArrayList: 可以看作是能够自动增长容量的数组**

     **LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。**

4. Q：hashmap 扩容机制？加载因子

   HashMap的容量，默认是16

   HashMap的加载因子，默认是0.75

   这种数组+链表的数据结构，使得HashMap可以较为高效的管理每一个节点。

   从JDK1.8开始，在HashMap里面定义了一个常量TREEIFY_THRESHOLD，默认为8。当链表中的节点数量大于TREEIFY_THRESHOLD时，链表将会考虑改为红黑树

5. Q：同步snyc 无锁，偏向锁，几种状态？voli？底层原理内存屏障？

   他可以确保同一个时刻最多只有一个线程执行同步代码，从而保证多线程环境下并发安全的效果。 如果有一段代码被Synchronized所修饰，那么这段代码就会以原子的方式执行，当多个线程在执行这段代码的时候，它们是互斥的，不会相互干扰，不会同时执行。

   ![image-20210718153610023](https://img-blog.csdnimg.cn/img_convert/f61be61be3b69735d3589a32faa8172c.png)

   ### 无锁

   顾名思义就是没有对资源进行锁定，所有线程都能访问到同一资源。这就涉及到多种情况

   1. 无竞争：线程之间不存在竞争直接获取资源就可以了
   2. 存在竞争：使用非锁方式实现同步线程。这就是我们耳熟能详的CAS（Compare And Swap）

   ### 偏向锁

   现在我们给对象开始加锁，假如一个对象被加锁了，但在实际运行时只有一个线程会获取这个对象锁。那么我们最理想的情况就是不通过线程状态切换，也不需要通过CAS来获得锁，因为这多多少少还是会耗费一些资源。我们设想的是最好对象能够认识这个线程，只要是这个线程过来，那么对象直接把锁交出去，我们就可以认为这个锁偏爱这个线程，所以被称为偏向锁，那么偏向锁是如何实现的？
   我们先通过判断后三位来判断是否是偏向锁，如果是偏向锁的话，它的前23位就是用来记录偏爱的进程ID。

   ### 轻量级锁（自旋锁）

   如果对象发现目前不知有一个线程，而是有多个线程正在竞争锁，那么偏向锁就会升级成轻量级锁。

   当锁的状态还是偏向锁时，是通过Mark Word中的线程id来找到线程，那么当锁的状态升级到轻量级锁的时候，如何判断线程和锁之间的绑定关系呢？

   图中给出了答案：通过前30位来指向栈中锁记录的指针。

   ### 重量级锁

   如果对象锁状态被标记为重量级锁，那么就是和我们最初讲的那样，需要通过Monitor来对线程进行控制，此时将会完全锁定资源，对线程的管控最为严格。

6. Q：springcloud？

   1.SpringBoot专注于快速方便的开发单个个体微服务。

   2.SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并且管理起来，为各个服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、精选决策、分布式会话等集成服务。

   3.SpringBoot可以离开SpringCloud独立开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。

   4.SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。

7. Q：ioc的具体加载过程？

   上图为[SpringBoot启动结构图](https://www.processon.com/view/link/59812124e4b0de2518b32b6e)，我们发现启动流程主要分为三个部分，

   第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器，

   第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块，

   第三部分是自动化配置模块，该模块作为springboot自动配置核心

   @SpringBootApplication包括三个注解，功能如下：@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置

   @SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境

   @ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下

8. Q：循环依赖，spring怎么解决？

9. Q：spring 三级缓存？

10. Q：springboot注解？configration具体干啥？

    它是对**约定优于配置**这个理念下 的一个最佳实践。因此它是一个服务于框架的框架，服务的范围是**简化配置文件**。

    @Configuration的作用：标注在类上，配置spring容器(应用上下文)。相当于把该类作为spring的xml配置文件中的`<beans>`。@Configuration注解的类中，使用@Bean注解标注的方法，返回的类型都会直接注册为bean。

11. Q：contail restcontail变化？

    @RestController的作用相当于@Controller和@ResponseBody一起使用的结果。

    以前我们都是在Controller类上使用注解@Controller，然后在这个controller里需要返回数据的方法上使用@ResponseBody，然后这个接口就会在被请求时返回数据；但是在需要跳转页面的方法上我们就不能使用@ResponseBody注解了。

    @RestController使用在controller类上之后，这个controller中的所有方法都会返回数据，不再跳转页面。

    了解这些之后，@Controller和@RestController的使用就会方便很多，根据具体情况选择使用。

12. Q：数据库行锁，表锁？一般业务多线程查询是什么锁？

    InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁

    **InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁**。

    ### 行锁

    行锁的劣势：开销大；加锁慢；会出现死锁

    行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强

    加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：

    共享锁：select * from tableName where … + lock in share more

    排他锁：select * from tableName where … + for update

    ### 表锁

    表锁的优势：开销小；加锁快；无死锁

    表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低

    加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：

    共享读锁：lock table tableName read;

    独占写锁：lock table tableName write;

    批量解锁：unlock tables;

    ## 总结

    1 InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。

    2 InnoDB 自动给修改操作加锁，给查询操作不自动加锁

    3 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。

    4 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。

    5 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。

    6 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。

13. Q：MySQL 事务属性

    事务是由一组SQL语句组成的逻辑处理单元，事务具有ACID属性。

    **原子性**（Atomicity）：事务是一个原子操作单元。在当时原子是不可分割的最小元素，其对数据的修改，要么全部成功，要么全部都不成功。

    **一致性**（Consistent）：事务开始到结束的时间段内，数据都必须保持一致状态。

    **隔离性**（Isolation）：数据库[系统](https://www.2cto.com/os/)提供一定的隔离机制，保证事务在不受外部并发操作影响的”独立”环境执行。

    **持久性**（Durable）：事务完成后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

14. Q：sql 索引？目的？注意哪些问题？

    一般你们会在什么情况下加索引
    （1）主键自动建立唯一索引
    （2）频繁作为查询条件的字段应该创建索引
    （3）查询中与其他表关联的字段，外键关系建立索引
    （4）单键/组合索引的选择问题，组合索引的性价比更高
    （5）查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
    （6）查询中统计或者分组字段。
    （7）过滤条件好的字段选择一段选择加索引

    **什么情况下会使索引失效？**
    （1）like
    （2）like “%123%，前面不能+%
    （3）使用 关键字 in ，or ，null，!=

    创建表时，不能在同一个字段上建立两个索引(主键默认建立唯一索引)，在需要 **经常查询**的字段上建立索引

     **一个表中可以有多个唯一性索引，但只能有一个主键。**

    **索引检索为什么快**：索引结构：B+Tree

    普通索引
    这是最基本的索引类型，而且它没有唯一性之类的限制。普通索引可以通过以下几种方式创建：

    唯一性索引
    这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。

    索引的缺点：

    第一， 索引要占用磁盘空间，如果你有一个很大的表，索引文件的大小可能达到操作系统允许的最大文件限制；

    第二，对于需要写入数据的操作，比如DELETE、UPDATE以及INSERT操作，索引会降低它们的速度。这是因为MySQL不仅要把改动数据写入数据文件，而且它还要把这些改动写入索引文件。

    **sql优化您们是怎么做的？**

    一.首先开启数据库慢查询日志，定位到查询效率比较低的sql , 找出对应的sql语句并进行分析
    1.表设计是否规范，是否符合三范式的标准
    （1）第一范式：保证原子性（不可拆分）
    （2）第二范式：每张表都有主键
    （3）第三范式（每一列都有主键相关)
    2.查看数据表中是否存在大量的冗余字段，字段数据类型是否合理
    3.尽可能的使用varchar代替char 建表数据类型，能用数值的绝对不用字符存储
    4.尽量避免null值，使用默认值替代空值，数值型可以使用0，字符型可以使用空字符串

    二.查看sql语句是否规范
    （1）避免使用关键字：or ，in，not in ，!=，<>，避免使用select *
    （2）尽量避免子查询，大部分子查询都可以连接查询
    （3）用到or的地方可以使用union去代替实现
    （4）用到in的地方可以使用exists去代替

    三.分析sql的索引是否可以用上
    （1) explain查询sql的执行计划,重点关注的几个列就是，type是不是全表扫描
    （2）看一下索引是否能够用的上,主要看key使用的是哪个索引
    （3）看一下rows扫描行数是不是很大

15. Q：mq消息 延迟，消息堆积？

    消息堆积问题：

    1.消费过程中由于访问共享资源加锁、I/O和网络资源竞争、业务处理复杂，数据库阻塞等原因，都会导致单条消息的消费时间过长，导致消息开始在服务端堆积。这种情况可以认为是代码问题，需要在代码层面做出调整。
    2.消费者单条消费性能没有问题，可以考虑消费者需要扩容。
    3.RocketMQ部分Broker没有TOPIC的消费订阅，这种情况的现象就是一部分部分broker的TOPIC被消费，但是另一部分的broker的TOPIC没有被消费。这种情况需要通过命令在相应的broker上创建对于的订阅消息。

    消息延迟问题：

    什么是定时消息和延迟消息？定时消息与延迟消息在代码配置上存在一些差异，但是最终达到的效果相同：消息在发送到 MQ 服务端后并不会立马投递，而是根据消息中的属性延迟固定时间后才投递给消费者。

16. Q：redis 分布式锁？

    Redis实现分布式锁主要利用Redis的`setnx`命令。`setnx`是`SET if not exists`(如果不存在，则 SET)的简写。

16. Q：apollo架构？怎么实现？

17. Q：git 合并多次commit？reset？rebase？
